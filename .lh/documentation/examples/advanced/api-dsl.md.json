{
    "sourceFile": "documentation/examples/advanced/api-dsl.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1749703043530,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1749703043530,
            "name": "Commit-0",
            "content": "# Production API DSL Example\n\n> **Build a complete REST API DSL** - Real-world example with authentication, validation, and documentation\n\n## ðŸŽ¯ What You'll Build\n\nA production-ready API DSL that generates complete REST APIs with:\n- âœ… **Route definitions** with HTTP methods and paths\n- âœ… **Authentication** with multiple strategies\n- âœ… **Request/response validation** with custom schemas\n- âœ… **Rate limiting** and caching\n- âœ… **Auto-generated documentation** and OpenAPI specs\n- âœ… **Testing utilities** for API endpoints\n\n## ðŸ—ï¸ Complete Implementation\n\n### **Step 1: Generate the DSL Structure**\n\n```bash\n# Generate the main API DSL\nmix spark.gen.dsl MyApp.ApiDsl \\\n  --section routes \\\n  --section authentication \\\n  --section middleware \\\n  --entity route:path:string \\\n  --entity auth_strategy:name:atom \\\n  --entity middleware:name:atom \\\n  --opt base_url:string:/api/v1 \\\n  --opt version:string:v1 \\\n  --opt rate_limit:integer:1000 \\\n  --examples\n```\n\n### **Step 2: Enhanced DSL Definition**\n\n```elixir\n# lib/my_app/api_dsl/dsl.ex\ndefmodule MyApp.ApiDsl.Dsl do\n  defmodule Route do\n    defstruct [:path, :method, :controller, :action, :auth, :rate_limit, :cache_ttl]\n  end\n\n  defmodule AuthStrategy do\n    defstruct [:name, :type, :config, :required_roles]\n  end\n\n  defmodule Middleware do\n    defstruct [:name, :module, :config, :order]\n  end\n\n  @route %Spark.Dsl.Entity{\n    name: :route,\n    args: [:path, :method],\n    target: Route,\n    describe: \"Define an API route with HTTP method and path\",\n    schema: [\n      path: [\n        type: :string,\n        required: true,\n        doc: \"The URL path for this route (e.g., '/users/:id')\"\n      ],\n      method: [\n        type: {:one_of, [:get, :post, :put, :patch, :delete]},\n        required: true,\n        doc: \"The HTTP method for this route\"\n      ],\n      controller: [\n        type: :module,\n        required: true,\n        doc: \"The controller module that handles this route\"\n      ],\n      action: [\n        type: :atom,\n        required: true,\n        doc: \"The controller action function name\"\n      ],\n      auth: [\n        type: :atom,\n        doc: \"The authentication strategy to use for this route\"\n      ],\n      rate_limit: [\n        type: :pos_integer,\n        doc: \"Rate limit for this route (requests per minute)\"\n      ],\n      cache_ttl: [\n        type: :pos_integer,\n        doc: \"Cache TTL in seconds for this route\"\n      ],\n      validate_request: [\n        type: :module,\n        doc: \"Module containing request validation schema\"\n      ],\n      validate_response: [\n        type: :module,\n        doc: \"Module containing response validation schema\"\n      ]\n    ]\n  }\n\n  @auth_strategy %Spark.Dsl.Entity{\n    name: :auth_strategy,\n    args: [:name, :type],\n    target: AuthStrategy,\n    describe: \"Define an authentication strategy\",\n    schema: [\n      name: [\n        type: :atom,\n        required: true,\n        doc: \"Unique name for this authentication strategy\"\n      ],\n      type: [\n        type: {:one_of, [:bearer_token, :api_key, :oauth2, :session]},\n        required: true,\n        doc: \"Type of authentication\"\n      ],\n      config: [\n        type: :keyword_list,\n        doc: \"Configuration options for this auth strategy\"\n      ],\n      required_roles: [\n        type: {:list, :atom},\n        doc: \"Required roles for this auth strategy\"\n      ]\n    ]\n  }\n\n  @middleware %Spark.Dsl.Entity{\n    name: :middleware,\n    args: [:name, :module],\n    target: Middleware,\n    describe: \"Define middleware for request processing\",\n    schema: [\n      name: [\n        type: :atom,\n        required: true,\n        doc: \"Unique name for this middleware\"\n      ],\n      module: [\n        type: :module,\n        required: true,\n        doc: \"The middleware module to use\"\n      ],\n      config: [\n        type: :keyword_list,\n        doc: \"Configuration options for this middleware\"\n      ],\n      order: [\n        type: :integer,\n        default: 0,\n        doc: \"Execution order (lower numbers execute first)\"\n      ]\n    ]\n  }\n\n  @routes %Spark.Dsl.Section{\n    name: :routes,\n    describe: \"Define API routes\",\n    entities: [@route],\n    schema: [\n      prefix: [\n        type: :string,\n        doc: \"URL prefix for all routes in this section\"\n      ]\n    ]\n  }\n\n  @authentication %Spark.Dsl.Section{\n    name: :authentication,\n    describe: \"Configure authentication strategies\",\n    entities: [@auth_strategy],\n    schema: [\n      default_strategy: [\n        type: :atom,\n        doc: \"Default authentication strategy to use\"\n      ]\n    ]\n  }\n\n  @middleware_section %Spark.Dsl.Section{\n    name: :middleware,\n    describe: \"Configure request middleware\",\n    entities: [@middleware],\n    schema: [\n      global_timeout: [\n        type: :pos_integer,\n        default: 30_000,\n        doc: \"Global request timeout in milliseconds\"\n      ]\n    ]\n  }\n\n  use Spark.Dsl.Extension,\n    sections: [@routes, @authentication, @middleware_section]\nend\n```\n\n### **Step 3: Main DSL Module**\n\n```elixir\n# lib/my_app/api_dsl.ex\ndefmodule MyApp.ApiDsl do\n  use Spark.Dsl,\n    default_extensions: [\n      extensions: [MyApp.ApiDsl.Dsl]\n    ]\n\n  def build_router(module) do\n    routes = MyApp.ApiDsl.Info.routes(module)\n    auth_strategies = MyApp.ApiDsl.Info.auth_strategies(module)\n    middleware = MyApp.ApiDsl.Info.middleware(module)\n\n    %{\n      routes: build_route_specs(routes, auth_strategies),\n      middleware: build_middleware_chain(middleware),\n      base_url: get_base_url(module),\n      version: get_version(module)\n    }\n  end\n\n  defp build_route_specs(routes, auth_strategies) do\n    Enum.map(routes, fn route ->\n      auth_config = get_auth_config(route.auth, auth_strategies)\n      \n      %{\n        path: route.path,\n        method: route.method,\n        controller: route.controller,\n        action: route.action,\n        auth: auth_config,\n        rate_limit: route.rate_limit,\n        cache_ttl: route.cache_ttl,\n        validate_request: route.validate_request,\n        validate_response: route.validate_response\n      }\n    end)\n  end\n\n  defp get_auth_config(nil, _), do: nil\n  defp get_auth_config(auth_name, auth_strategies) do\n    Enum.find(auth_strategies, &(&1.name == auth_name))\n  end\n\n  defp build_middleware_chain(middleware) do\n    middleware\n    |> Enum.sort_by(& &1.order)\n    |> Enum.map(fn mw -> {mw.module, mw.config} end)\n  end\n\n  defp get_base_url(module) do\n    case MyApp.ApiDsl.Info.routes(module) do\n      [%{prefix: prefix} | _] -> prefix\n      _ -> \"/api/v1\"\n    end\n  end\n\n  defp get_version(module) do\n    case MyApp.ApiDsl.Info.routes(module) do\n      [%{version: version} | _] -> version\n      _ -> \"v1\"\n    end\n  end\nend\n```\n\n### **Step 4: Transformers for Advanced Features**\n\n```elixir\n# lib/my_app/api_dsl/transformers/add_defaults.ex\ndefmodule MyApp.ApiDsl.Transformers.AddDefaults do\n  use Spark.Dsl.Transformer\n\n  def transform(dsl_state) do\n    {:ok,\n     dsl_state\n     |> add_default_auth_strategy()\n     |> add_default_middleware()\n     |> add_route_validation()}\n  end\n\n  defp add_default_auth_strategy(dsl_state) do\n    case has_auth_strategy?(dsl_state, :public) do\n      true -> dsl_state\n      false ->\n        add_entity(dsl_state, [:authentication], %MyApp.ApiDsl.Dsl.AuthStrategy{\n          name: :public,\n          type: :session,\n          config: [allow_anonymous: true]\n        })\n    end\n  end\n\n  defp add_default_middleware(dsl_state) do\n    default_middleware = [\n      %MyApp.ApiDsl.Dsl.Middleware{\n        name: :cors,\n        module: MyApp.ApiDsl.Middleware.Cors,\n        config: [origins: [\"*\"]],\n        order: 1\n      },\n      %MyApp.ApiDsl.Dsl.Middleware{\n        name: :logging,\n        module: MyApp.ApiDsl.Middleware.Logging,\n        config: [level: :info],\n        order: 2\n      }\n    ]\n\n    Enum.reduce(default_middleware, dsl_state, fn mw, state ->\n      case has_middleware?(state, mw.name) do\n        true -> state\n        false -> add_entity(state, [:middleware], mw)\n      end\n    end)\n  end\n\n  defp add_route_validation(dsl_state) do\n    routes = get_entities(dsl_state, [:routes])\n    \n    Enum.reduce(routes, dsl_state, fn route, state ->\n      if route.validate_request do\n        add_entity(state, [:routes], %{route | \n          validate_request: ensure_validation_module(route.validate_request)\n        })\n      else\n        state\n      end\n    end)\n  end\n\n  defp ensure_validation_module(module) do\n    if Code.ensure_loaded?(module) do\n      module\n    else\n      MyApp.ApiDsl.Validation.Default\n    end\n  end\nend\n```\n\n### **Step 5: Verifiers for Validation**\n\n```elixir\n# lib/my_app/api_dsl/verifiers/validate_routes.ex\ndefmodule MyApp.ApiDsl.Verifiers.ValidateRoutes do\n  use Spark.Dsl.Verifier\n\n  def verify(dsl_state) do\n    routes = MyApp.ApiDsl.Info.routes(dsl_state)\n    auth_strategies = MyApp.ApiDsl.Info.auth_strategies(dsl_state)\n\n    with :ok <- validate_route_paths(routes),\n         :ok <- validate_auth_references(routes, auth_strategies),\n         :ok <- validate_controller_actions(routes) do\n      :ok\n    end\n  end\n\n  defp validate_route_paths(routes) do\n    paths = Enum.map(routes, & &1.path)\n    \n    case find_duplicate_paths(paths) do\n      [] -> :ok\n      duplicates ->\n        {:error,\n         Spark.Error.DslError.exception(\n           message: \"Duplicate route paths: #{inspect(duplicates)}\",\n           path: [:routes]\n         )}\n    end\n  end\n\n  defp validate_auth_references(routes, auth_strategies) do\n    auth_names = MapSet.new(auth_strategies, & &1.name)\n    \n    invalid_auth = routes\n    |> Enum.filter(& &1.auth)\n    |> Enum.reject(&(&1.auth in auth_names))\n    |> Enum.map(& &1.auth)\n\n    case invalid_auth do\n      [] -> :ok\n      invalid ->\n        {:error,\n         Spark.Error.DslError.exception(\n           message: \"Invalid auth strategy references: #{inspect(invalid)}\",\n           path: [:routes]\n         )}\n    end\n  end\n\n  defp validate_controller_actions(routes) do\n    invalid_controllers = routes\n    |> Enum.reject(&controller_action_exists?/1)\n\n    case invalid_controllers do\n      [] -> :ok\n      invalid ->\n        {:error,\n         Spark.Error.DslError.exception(\n           message: \"Invalid controller/action combinations: #{inspect(invalid)}\",\n           path: [:routes]\n         )}\n    end\n  end\n\n  defp controller_action_exists?(%{controller: controller, action: action}) do\n    Code.ensure_loaded?(controller) and function_exported?(controller, action, 2)\n  end\n\n  defp find_duplicate_paths(paths) do\n    paths\n    |> Enum.frequencies()\n    |> Enum.filter(fn {_path, count} -> count > 1 end)\n    |> Enum.map(fn {path, _} -> path end)\n  end\nend\n```\n\n### **Step 6: Usage Example**\n\n```elixir\n# lib/my_app/api.ex\ndefmodule MyApp.Api do\n  use MyApp.ApiDsl\n\n  authentication do\n    default_strategy :bearer_token\n    \n    auth_strategy :bearer_token, :bearer_token do\n      config [\n        token_header: \"Authorization\",\n        token_prefix: \"Bearer\"\n      ]\n      required_roles [:user, :admin]\n    end\n\n    auth_strategy :api_key, :api_key do\n      config [\n        header: \"X-API-Key\",\n        env_var: \"API_KEY\"\n      ]\n      required_roles [:service]\n    end\n\n    auth_strategy :public, :session do\n      config [allow_anonymous: true]\n    end\n  end\n\n  middleware do\n    global_timeout 30_000\n\n    middleware :cors, MyApp.ApiDsl.Middleware.Cors do\n      config [\n        origins: [\"https://myapp.com\", \"https://admin.myapp.com\"],\n        methods: [\"GET\", \"POST\", \"PUT\", \"DELETE\"],\n        headers: [\"Content-Type\", \"Authorization\"]\n      ]\n      order 1\n    end\n\n    middleware :rate_limiting, MyApp.ApiDsl.Middleware.RateLimiting do\n      config [\n        redis_url: System.get_env(\"REDIS_URL\"),\n        default_limit: 1000\n      ]\n      order 2\n    end\n\n    middleware :logging, MyApp.ApiDsl.Middleware.Logging do\n      config [level: :info]\n      order 3\n    end\n  end\n\n  routes do\n    prefix \"/api/v1\"\n\n    route \"/health\", :get do\n      controller MyApp.Api.HealthController\n      action :check\n      auth :public\n      cache_ttl 300\n    end\n\n    route \"/users\", :get do\n      controller MyApp.Api.UserController\n      action :index\n      auth :bearer_token\n      rate_limit 100\n      validate_request MyApp.Api.Validation.UserListRequest\n      validate_response MyApp.Api.Validation.UserListResponse\n    end\n\n    route \"/users/:id\", :get do\n      controller MyApp.Api.UserController\n      action :show\n      auth :bearer_token\n      rate_limit 200\n      cache_ttl 600\n      validate_request MyApp.Api.Validation.UserShowRequest\n      validate_response MyApp.Api.Validation.UserShowResponse\n    end\n\n    route \"/users\", :post do\n      controller MyApp.Api.UserController\n      action :create\n      auth :bearer_token\n      rate_limit 10\n      validate_request MyApp.Api.Validation.UserCreateRequest\n      validate_response MyApp.Api.Validation.UserCreateResponse\n    end\n\n    route \"/admin/users\", :get do\n      controller MyApp.Api.AdminController\n      action :list_users\n      auth :api_key\n      rate_limit 50\n    end\n  end\nend\n```\n\n### **Step 7: Controller Implementation**\n\n```elixir\n# lib/my_app/api/user_controller.ex\ndefmodule MyApp.Api.UserController do\n  use Phoenix.Controller\n\n  def index(conn, params) do\n    # Request validation happens automatically via middleware\n    users = MyApp.Users.list_users(params)\n    \n    # Response validation happens automatically\n    json(conn, %{\n      data: users,\n      meta: %{\n        total: length(users),\n        page: params[\"page\"] || 1\n      }\n    })\n  end\n\n  def show(conn, %{\"id\" => id}) do\n    case MyApp.Users.get_user(id) do\n      nil -> \n        conn\n        |> put_status(404)\n        |> json(%{error: \"User not found\"})\n      \n      user ->\n        json(conn, %{data: user})\n    end\n  end\n\n  def create(conn, params) do\n    case MyApp.Users.create_user(params) do\n      {:ok, user} ->\n        conn\n        |> put_status(201)\n        |> json(%{data: user})\n      \n      {:error, changeset} ->\n        conn\n        |> put_status(422)\n        |> json(%{errors: format_errors(changeset)})\n    end\n  end\n\n  defp format_errors(changeset) do\n    Ecto.Changeset.traverse_errors(changeset, fn {msg, opts} ->\n      Enum.reduce(opts, msg, fn {key, value}, acc ->\n        String.replace(acc, \"%{#{key}}\", to_string(value))\n      end)\n    end)\n  end\nend\n```\n\n### **Step 8: Validation Schemas**\n\n```elixir\n# lib/my_app/api/validation/user_list_request.ex\ndefmodule MyApp.Api.Validation.UserListRequest do\n  use Spark.Dsl\n\n  def validate(params) do\n    schema = %{\n      \"page\" => [type: :integer, min: 1, default: 1],\n      \"per_page\" => [type: :integer, min: 1, max: 100, default: 20],\n      \"search\" => [type: :string, max_length: 100],\n      \"sort_by\" => [type: {:one_of, [\"name\", \"email\", \"created_at\"]}, default: \"created_at\"],\n      \"sort_order\" => [type: {:one_of, [\"asc\", \"desc\"]}, default: \"desc\"]\n    }\n\n    validate_schema(params, schema)\n  end\n\n  defp validate_schema(params, schema) do\n    # Implementation of schema validation\n    {:ok, validated_params}\n  end\nend\n```\n\n### **Step 9: Router Integration**\n\n```elixir\n# lib/my_app_web/router.ex\ndefmodule MyAppWeb.Router do\n  use MyAppWeb, :router\n\n  # Build the API router from DSL\n  api_spec = MyApp.Api.build_router(MyApp.Api)\n\n  # Apply middleware\n  pipeline :api do\n    plug :accepts, [\"json\"]\n    \n    # Apply DSL-defined middleware\n    Enum.each(api_spec.middleware, fn {module, config} ->\n      plug module, config\n    end)\n  end\n\n  scope api_spec.base_url, MyAppWeb do\n    pipe_through :api\n\n    # Generate routes from DSL\n    Enum.each(api_spec.routes, fn route ->\n      case route.method do\n        :get -> get route.path, route.controller, route.action\n        :post -> post route.path, route.controller, route.action\n        :put -> put route.path, route.controller, route.action\n        :patch -> patch route.path, route.controller, route.action\n        :delete -> delete route.path, route.controller, route.action\n      end\n    end)\n  end\nend\n```\n\n### **Step 10: Testing**\n\n```elixir\n# test/my_app/api_test.exs\ndefmodule MyApp.ApiTest do\n  use ExUnit.Case\n  use MyAppWeb.ConnCase\n\n  test \"health endpoint works without authentication\" do\n    conn = get(build_conn(), \"/api/v1/health\")\n    assert conn.status == 200\n    assert json_response(conn, 200)[\"status\"] == \"ok\"\n  end\n\n  test \"users endpoint requires authentication\" do\n    conn = get(build_conn(), \"/api/v1/users\")\n    assert conn.status == 401\n  end\n\n  test \"users endpoint works with valid token\" do\n    token = generate_test_token()\n    \n    conn = build_conn()\n    |> put_req_header(\"authorization\", \"Bearer #{token}\")\n    |> get(\"/api/v1/users\")\n    \n    assert conn.status == 200\n    assert is_map(json_response(conn, 200)[\"data\"])\n  end\n\n  test \"rate limiting works\" do\n    token = generate_test_token()\n    \n    # Make requests up to the limit\n    Enum.each(1..100, fn _ ->\n      conn = build_conn()\n      |> put_req_header(\"authorization\", \"Bearer #{token}\")\n      |> get(\"/api/v1/users\")\n      \n      assert conn.status in [200, 429]\n    end)\n  end\n\n  defp generate_test_token do\n    # Implementation of test token generation\n    \"test_token_123\"\n  end\nend\n```\n\n## ðŸŽ¯ Key Features Demonstrated\n\n### **1. Declarative API Definition**\n- Routes defined with clear, readable syntax\n- Authentication strategies configured declaratively\n- Middleware chain built automatically\n\n### **2. Compile-Time Validation**\n- Route path conflicts detected at compile time\n- Authentication strategy references validated\n- Controller/action existence verified\n\n### **3. Runtime Introspection**\n- Complete API specification available at runtime\n- Route metadata accessible for documentation\n- Middleware configuration queryable\n\n### **4. Extensibility**\n- Easy to add new authentication strategies\n- Middleware can be added without code changes\n- Route validation schemas pluggable\n\n### **5. Production Features**\n- Rate limiting built-in\n- Caching configuration\n- Request/response validation\n- Comprehensive error handling\n\n## ðŸš€ Next Steps\n\n1. **[Add OpenAPI generation](advanced/openapi-generation.md)** - Auto-generate API documentation\n2. **[Implement caching middleware](advanced/caching.md)** - Add Redis-based caching\n3. **[Add monitoring](advanced/monitoring.md)** - Integrate with observability tools\n4. **[Performance optimization](guides/performance/api-dsl.md)** - Optimize for high throughput\n\n---\n\n**Ready to build your own API DSL?** [Start with the basics â†’](../tutorials/generators/first-dsl.md) "
        }
    ]
}