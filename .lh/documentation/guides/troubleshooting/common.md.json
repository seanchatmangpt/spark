{
    "sourceFile": "documentation/guides/troubleshooting/common.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1749702986441,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1749702986441,
            "name": "Commit-0",
            "content": "# Common Issues and Solutions\n\n> **Quick fixes for the most frequent Spark DSL problems** - Get back to building in minutes\n\n## üö® Critical Issues\n\n### **\"Module not found\" Errors**\n\n#### **Problem**\n```elixir\n** (CompileError) module MyApp.Validator.Dsl not found\n```\n\n#### **Solution**\n1. **Check dependencies** - Ensure Spark is in your `mix.exs`:\n   ```elixir\n   defp deps do\n     [\n       {:spark, \"~> 2.2.65\"},\n       {:igniter, \"~> 0.6.6\", only: [:dev]}\n     ]\n   end\n   ```\n\n2. **Install dependencies**:\n   ```bash\n   mix deps.get\n   mix deps.compile\n   ```\n\n3. **Restart your editor** - Sometimes editors cache module information\n\n4. **Check file structure** - Ensure your DSL module is in the correct location:\n   ```\n   lib/my_app/validator/dsl.ex  # MyApp.Validator.Dsl\n   lib/my_app/validator.ex      # MyApp.Validator\n   ```\n\n### **\"Invalid DSL syntax\" Errors**\n\n#### **Problem**\n```elixir\n** (Spark.Error.DslError) Invalid DSL syntax at [:fields, :field, :name]\n```\n\n#### **Solution**\n1. **Check entity definition** - Ensure your entity matches the schema:\n   ```elixir\n   @field %Spark.Dsl.Entity{\n     name: :field,\n     args: [:name, :type],  # Required arguments\n     schema: [\n       name: [type: :atom, required: true],\n       type: [type: {:one_of, [:string, :integer]}, required: true]\n     ]\n   }\n   ```\n\n2. **Verify usage** - Ensure you're using the DSL correctly:\n   ```elixir\n   # Correct\n   field :name, :string\n   \n   # Incorrect - missing required argument\n   field :name\n   ```\n\n3. **Check types** - Ensure values match the expected types:\n   ```elixir\n   # Correct\n   field :name, :string, required: true\n   \n   # Incorrect - boolean expected\n   field :name, :string, required: \"true\"\n   ```\n\n### **\"Transformer not found\" Errors**\n\n#### **Problem**\n```elixir\n** (CompileError) module MyApp.Transformers.AddDefaults not found\n```\n\n#### **Solution**\n1. **Create the transformer**:\n   ```bash\n   mix spark.gen.transformer MyApp.Transformers.AddDefaults \\\n     --dsl MyApp.Validator \\\n     --examples\n   ```\n\n2. **Check module name** - Ensure the transformer module exists and is correctly named\n\n3. **Verify dependencies** - Ensure the transformer is compiled before the DSL\n\n## üîß DSL Definition Issues\n\n### **Schema Validation Errors**\n\n#### **Problem**\n```elixir\n** (Spark.Error.DslError) Invalid value for :type: expected one of [:string, :integer], got :float\n```\n\n#### **Solution**\n1. **Check schema definition** - Ensure your schema includes all valid types:\n   ```elixir\n   schema: [\n     type: [\n       type: {:one_of, [:string, :integer, :float]},  # Add :float\n       required: true\n     ]\n   ]\n   ```\n\n2. **Use custom validation** for complex types:\n   ```elixir\n   schema: [\n     type: [\n       type: {:custom, __MODULE__, :validate_type, []},\n       required: true\n     ]\n   ]\n\n   def validate_type(value) when value in [:string, :integer, :float], do: {:ok, value}\n   def validate_type(value), do: {:error, \"Invalid type: #{inspect(value)}\"}\n   ```\n\n### **Missing Required Arguments**\n\n#### **Problem**\n```elixir\n** (Spark.Error.DslError) Missing required argument :name for entity :field\n```\n\n#### **Solution**\n1. **Check entity definition** - Ensure `args` includes all required arguments:\n   ```elixir\n   @field %Spark.Dsl.Entity{\n     name: :field,\n     args: [:name, :type],  # Both are required\n     schema: [\n       name: [type: :atom, required: true],\n       type: [type: :atom, required: true]\n     ]\n   }\n   ```\n\n2. **Update usage** - Provide all required arguments:\n   ```elixir\n   # Correct\n   field :name, :string\n   \n   # Incorrect - missing :type\n   field :name\n   ```\n\n### **Invalid Entity Structure**\n\n#### **Problem**\n```elixir\n** (Spark.Error.DslError) Invalid entity structure: expected :name, got :field_name\n```\n\n#### **Solution**\n1. **Check entity name** - Ensure the entity name matches the DSL keyword:\n   ```elixir\n   @field %Spark.Dsl.Entity{\n     name: :field,  # This becomes the DSL keyword\n     # ...\n   }\n   ```\n\n2. **Use consistent naming** - The entity name should match your DSL usage:\n   ```elixir\n   # DSL usage\n   field :name, :string\n   \n   # Entity definition\n   @field %Spark.Dsl.Entity{name: :field, ...}\n   ```\n\n## üîÑ Runtime Issues\n\n### **Info Module Not Found**\n\n#### **Problem**\n```elixir\n** (UndefinedFunctionError) function MyApp.Validator.Info.fields/1 is undefined\n```\n\n#### **Solution**\n1. **Generate info module**:\n   ```bash\n   mix spark.gen.info MyApp.Validator.Info \\\n     --extension MyApp.Validator.Dsl \\\n     --sections fields \\\n     --examples\n   ```\n\n2. **Check module name** - Ensure the info module name matches your DSL:\n   ```elixir\n   # DSL module\n   defmodule MyApp.Validator do\n     use Spark.Dsl, default_extensions: [extensions: [MyApp.Validator.Dsl]]\n   end\n   \n   # Info module\n   defmodule MyApp.Validator.Info do\n     use Spark.InfoGenerator, extension: MyApp.Validator.Dsl\n   end\n   ```\n\n### **Transformer Execution Errors**\n\n#### **Problem**\n```elixir\n** (FunctionClauseError) no function clause matching in MyApp.Transformers.AddDefaults.transform/1\n```\n\n#### **Solution**\n1. **Check transformer signature** - Ensure it matches the expected interface:\n   ```elixir\n   defmodule MyApp.Transformers.AddDefaults do\n     use Spark.Dsl.Transformer\n\n     def transform(dsl_state) do\n       # Must return {:ok, dsl_state} or {:error, reason}\n       {:ok, dsl_state}\n     end\n   end\n   ```\n\n2. **Handle all cases** - Ensure your transformer handles all possible inputs:\n   ```elixir\n   def transform(dsl_state) do\n     case has_section?(dsl_state, :fields) do\n       true -> {:ok, add_defaults(dsl_state)}\n       false -> {:ok, dsl_state}  # Handle missing section\n     end\n   end\n   ```\n\n### **Verifier Validation Errors**\n\n#### **Problem**\n```elixir\n** (Spark.Error.DslError) Verification failed: Invalid field configuration\n```\n\n#### **Solution**\n1. **Check verifier logic** - Ensure your verifier returns the correct format:\n   ```elixir\n   defmodule MyApp.Verifiers.ValidateFields do\n     use Spark.Dsl.Verifier\n\n     def verify(dsl_state) do\n       # Must return :ok or {:error, Spark.Error.DslError.t()}\n       case validate_fields(dsl_state) do\n         :ok -> :ok\n         {:error, message} -> \n           {:error, Spark.Error.DslError.exception(message: message)}\n       end\n     end\n   end\n   ```\n\n2. **Provide clear error messages** - Include context in error messages:\n   ```elixir\n   def verify(dsl_state) do\n     fields = MyApp.Validator.Info.fields(dsl_state)\n     \n     case find_invalid_fields(fields) do\n       [] -> :ok\n       invalid -> \n         {:error, \n          Spark.Error.DslError.exception(\n            message: \"Invalid fields: #{inspect(invalid)}\",\n            path: [:fields]\n          )}\n     end\n   end\n   ```\n\n## üéØ Generator Issues\n\n### **\"Generator not found\" Errors**\n\n#### **Problem**\n```bash\n** (Mix) The task \"spark.gen.dsl\" could not be found\n```\n\n#### **Solution**\n1. **Install Igniter** - Required for generators:\n   ```elixir\n   defp deps do\n     [\n       {:spark, \"~> 2.2.65\"},\n       {:igniter, \"~> 0.6.6\", only: [:dev]}  # Required for generators\n     ]\n   end\n   ```\n\n2. **Install dependencies**:\n   ```bash\n   mix deps.get\n   mix deps.compile\n   ```\n\n3. **Check Mix environment** - Ensure you're in the correct environment:\n   ```bash\n   MIX_ENV=dev mix spark.gen.dsl MyApp.Validator\n   ```\n\n### **Invalid Generator Options**\n\n#### **Problem**\n```bash\n** (Mix) Invalid option --invalid_option for task spark.gen.dsl\n```\n\n#### **Solution**\n1. **Check available options**:\n   ```bash\n   mix help spark.gen.dsl\n   ```\n\n2. **Use correct option format**:\n   ```bash\n   # Correct\n   mix spark.gen.dsl MyApp.Validator --section fields --examples\n   \n   # Incorrect\n   mix spark.gen.dsl MyApp.Validator --sections fields --example\n   ```\n\n3. **Check option values** - Ensure values match expected types:\n   ```bash\n   # Correct\n   mix spark.gen.dsl MyApp.Validator --opt required:boolean:false\n   \n   # Incorrect\n   mix spark.gen.dsl MyApp.Validator --opt required:boolean:true\n   ```\n\n### **Generator Output Issues**\n\n#### **Problem**\nGenerated files don't match expected structure or are missing.\n\n#### **Solution**\n1. **Check file permissions** - Ensure you can write to the target directory\n\n2. **Verify module names** - Ensure module names are valid:\n   ```bash\n   # Correct\n   mix spark.gen.dsl MyApp.Validator\n   \n   # Incorrect - invalid module name\n   mix spark.gen.dsl MyApp.validator\n   ```\n\n3. **Check for conflicts** - Ensure target files don't already exist:\n   ```bash\n   # Remove existing files first\n   rm lib/my_app/validator.ex\n   mix spark.gen.dsl MyApp.Validator\n   ```\n\n## üîç Debugging Tips\n\n### **Enable Debug Logging**\n```elixir\n# config/dev.exs\nconfig :spark, :debug, true\n```\n\n### **Check DSL State**\n```elixir\n# In your transformer or verifier\ndef transform(dsl_state) do\n  IO.inspect(dsl_state, label: \"DSL State\")\n  # ... your logic\nend\n```\n\n### **Validate DSL Manually**\n```elixir\n# Test DSL compilation\ndefmodule TestValidator do\n  use MyApp.Validator\n  \n  fields do\n    field :name, :string\n  end\nend\n\n# Check if it compiles\nCode.ensure_loaded?(TestValidator)\n```\n\n### **Check Generated Functions**\n```elixir\n# Verify info module functions\nMyApp.Validator.Info.__info__(:functions)\n```\n\n## üìû Getting More Help\n\n### **Self-Service Resources**\n- **[Generator Reference](reference/generators/)** - Complete generator documentation\n- **[API Documentation](https://hexdocs.pm/spark)** - Full API reference\n- **[Examples](../examples/)** - Working code examples\n\n### **Community Support**\n- **[Elixir Forum](https://elixirforum.com/c/ash-framework)** - Community discussions\n- **[GitHub Issues](https://github.com/ash-project/spark/issues)** - Bug reports\n- **[Discord](https://discord.gg/DQHqJ8k)** - Real-time chat\n\n### **When to Ask for Help**\n- ‚úÖ **Tried all solutions above** - You've exhausted self-service options\n- ‚úÖ **Have a minimal reproduction** - You can reproduce the issue in a simple example\n- ‚úÖ **Include error messages** - You have the complete error output\n- ‚úÖ **Show your code** - You're willing to share relevant code snippets\n\n### **What to Include When Asking for Help**\n1. **Complete error message** - Include the full stack trace\n2. **Minimal reproduction** - Code that reproduces the issue\n3. **Environment details** - Elixir version, Spark version, OS\n4. **What you've tried** - Steps you've already attempted\n\n---\n\n**Still stuck?** [Get community help ‚Üí](../README.md#-support) "
        }
    ]
}