{
    "sourceFile": "documentation/guides/performance/basics.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1749703089645,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1749703089645,
            "name": "Commit-0",
            "content": "# Performance Optimization Guide\n\n> **Optimize your Spark DSLs for production** - Techniques for maximum performance and minimal overhead\n\n## 🎯 Performance Goals\n\n### **Target Metrics**\n- **Compile time**: < 50ms for complex DSLs\n- **Runtime overhead**: < 1μs per Info function call\n- **Memory usage**: < 1KB per DSL instance\n- **Startup time**: < 100ms for DSL compilation\n\n### **Measurement Tools**\n```bash\n# Compile time profiling\nmix spark.analyze performance lib/my_app\n\n# Memory usage analysis\nmix spark.analyze memory MyApp.MyDsl\n\n# Runtime performance\nmix spark.analyze runtime MyApp.MyDsl.Info\n```\n\n## 🚀 Compile-Time Optimization\n\n### **1. Minimize DSL Complexity**\n\n#### **Problem**: Overly complex DSL definitions\n```elixir\n# ❌ Complex - many nested entities\n@field %Spark.Dsl.Entity{\n  name: :field,\n  entities: [\n    validation: @validation,\n    transformation: @transformation,\n    documentation: @documentation\n  ]\n}\n```\n\n#### **Solution**: Flatten structure where possible\n```elixir\n# ✅ Simple - flat structure\n@field %Spark.Dsl.Entity{\n  name: :field,\n  schema: [\n    name: [type: :atom, required: true],\n    type: [type: :atom, required: true],\n    validate: [type: :fun],\n    transform: [type: :fun],\n    doc: [type: :string]\n  ]\n}\n```\n\n### **2. Optimize Transformer Order**\n\n#### **Problem**: Inefficient transformer execution\n```elixir\n# ❌ Poor ordering - expensive operations first\ntransformers: [\n  MyApp.Transformers.ExpensiveOperation,  # Runs first\n  MyApp.Transformers.FilterData,          # Reduces data\n  MyApp.Transformers.AddDefaults          # Simple operation\n]\n```\n\n#### **Solution**: Order by cost and dependency\n```elixir\n# ✅ Optimized ordering - cheap operations first\ntransformers: [\n  MyApp.Transformers.AddDefaults,         # Simple, runs first\n  MyApp.Transformers.FilterData,          # Reduces data size\n  MyApp.Transformers.ExpensiveOperation   # Runs on smaller dataset\n]\n```\n\n### **3. Use Conditional Transformers**\n\n#### **Problem**: Unnecessary transformer execution\n```elixir\n# ❌ Always runs\ndef transform(dsl_state) do\n  # Expensive operation that's not always needed\n  expensive_operation(dsl_state)\nend\n```\n\n#### **Solution**: Conditional execution\n```elixir\n# ✅ Only runs when needed\ndef transform(dsl_state) do\n  if has_section?(dsl_state, :expensive_feature) do\n    expensive_operation(dsl_state)\n  else\n    {:ok, dsl_state}\n  end\nend\n```\n\n### **4. Optimize Schema Validation**\n\n#### **Problem**: Complex validation logic\n```elixir\n# ❌ Complex validation\nschema: [\n  type: [\n    type: {:custom, __MODULE__, :validate_complex_type, []}\n  ]\n]\n\ndef validate_complex_type(value) do\n  # Expensive validation logic\n  complex_validation(value)\nend\n```\n\n#### **Solution**: Use built-in validators\n```elixir\n# ✅ Simple validation\nschema: [\n  type: [\n    type: {:one_of, [:string, :integer, :float]},\n    required: true\n  ]\n]\n```\n\n## 🔄 Runtime Optimization\n\n### **1. Optimize Info Module Usage**\n\n#### **Problem**: Repeated expensive operations\n```elixir\n# ❌ Expensive - called multiple times\ndef process_data(module, data) do\n  fields = MyApp.Validator.Info.fields(module)  # Expensive\n  validate_fields(fields, data)\n  \n  # Later in the same function...\n  fields = MyApp.Validator.Info.fields(module)  # Expensive again\n  transform_fields(fields, data)\nend\n```\n\n#### **Solution**: Cache expensive operations\n```elixir\n# ✅ Efficient - cache the result\ndef process_data(module, data) do\n  fields = MyApp.Validator.Info.fields(module)  # Call once\n  \n  data\n  |> validate_fields(fields)\n  |> transform_fields(fields)\nend\n```\n\n### **2. Use Lazy Evaluation**\n\n#### **Problem**: Eager computation of unused data\n```elixir\n# ❌ Eager - computes everything\ndef get_field_info(module) do\n  fields = MyApp.Validator.Info.fields(module)\n  \n  %{\n    count: length(fields),\n    names: Enum.map(fields, & &1.name),\n    types: Enum.map(fields, & &1.type),\n    required: Enum.filter(fields, & &1.required)\n  }\nend\n```\n\n#### **Solution**: Lazy computation\n```elixir\n# ✅ Lazy - only compute what's needed\ndef get_field_info(module) do\n  %{\n    count: &(MyApp.Validator.Info.fields(module) |> length()),\n    names: &(MyApp.Validator.Info.fields(module) |> Enum.map(& &1.name)),\n    types: &(MyApp.Validator.Info.fields(module) |> Enum.map(& &1.type)),\n    required: &(MyApp.Validator.Info.fields(module) |> Enum.filter(& &1.required))\n  }\nend\n```\n\n### **3. Optimize Data Structures**\n\n#### **Problem**: Inefficient data access patterns\n```elixir\n# ❌ Linear search\ndef find_field(module, field_name) do\n  fields = MyApp.Validator.Info.fields(module)\n  Enum.find(fields, &(&1.name == field_name))\nend\n```\n\n#### **Solution**: Use indexed access\n```elixir\n# ✅ Constant time lookup\ndef find_field(module, field_name) do\n  MyApp.Validator.Info.field(module, field_name)\nend\n```\n\n### **4. Minimize Memory Allocations**\n\n#### **Problem**: Unnecessary data copying\n```elixir\n# ❌ Creates new data structures\ndef transform_data(module, data) do\n  fields = MyApp.Validator.Info.fields(module)\n  \n  Enum.reduce(fields, %{}, fn field, acc ->\n    Map.put(acc, field.name, transform_field(field, data))\n  end)\nend\n```\n\n#### **Solution**: In-place transformation\n```elixir\n# ✅ Modifies existing data\ndef transform_data(module, data) do\n  fields = MyApp.Validator.Info.fields(module)\n  \n  Enum.reduce(fields, data, fn field, acc ->\n    case Map.get(acc, field.name) do\n      nil -> acc\n      value -> Map.put(acc, field.name, transform_field(field, value))\n    end\n  end)\nend\n```\n\n## 📊 Profiling and Measurement\n\n### **1. Compile-Time Profiling**\n\n```bash\n# Profile DSL compilation\nmix spark.analyze performance lib/my_app\n\n# Output:\n# DSL Compilation Time:\n#   MyApp.Validator: 15ms\n#   MyApp.ApiDsl: 45ms\n#   MyApp.ConfigDsl: 8ms\n```\n\n### **2. Runtime Performance Analysis**\n\n```elixir\n# Measure Info function performance\ndefmodule MyApp.PerformanceTest do\n  use ExUnit.Case\n\n  test \"Info function performance\" do\n    module = MyApp.Validator\n    \n    # Measure function calls\n    {time, _result} = :timer.tc(fn ->\n      Enum.each(1..1000, fn _ ->\n        MyApp.Validator.Info.fields(module)\n      end)\n    end)\n    \n    avg_time = time / 1000\n    assert avg_time < 100  # Less than 100μs per call\n  end\nend\n```\n\n### **3. Memory Usage Analysis**\n\n```bash\n# Analyze memory usage\nmix spark.analyze memory MyApp.Validator\n\n# Output:\n# Memory Usage:\n#   DSL State: 2.3KB\n#   Info Module: 1.1KB\n#   Generated Functions: 0.8KB\n```\n\n### **4. Benchmarking Tools**\n\n```elixir\n# Use Benchee for detailed benchmarking\ndefmodule MyApp.Benchmark do\n  def run_benchmarks do\n    module = MyApp.Validator\n    \n    Benchee.run(%{\n      \"fields/1\" => fn -> MyApp.Validator.Info.fields(module) end,\n      \"field/2\" => fn -> MyApp.Validator.Info.field(module, :name) end,\n      \"validate/2\" => fn -> MyApp.Validator.validate(module, %{name: \"test\"}) end\n    })\n  end\nend\n```\n\n## 🎯 Production Optimization\n\n### **1. Environment-Specific Configuration**\n\n```elixir\n# config/prod.exs\nconfig :my_app, :spark,\n  compile_time_validations: true,\n  generate_docs: false,           # Disable in production\n  cache_info_modules: true,       # Enable caching\n  optimize_for_speed: true        # Enable optimizations\n```\n\n### **2. Caching Strategies**\n\n```elixir\n# Cache expensive Info operations\ndefmodule MyApp.CachedInfo do\n  use GenServer\n\n  def start_link do\n    GenServer.start_link(__MODULE__, %{}, name: __MODULE__)\n  end\n\n  def get_fields(module) do\n    GenServer.call(__MODULE__, {:get_fields, module})\n  end\n\n  def handle_call({:get_fields, module}, _from, cache) do\n    case Map.get(cache, module) do\n      nil ->\n        fields = MyApp.Validator.Info.fields(module)\n        {:reply, fields, Map.put(cache, module, fields)}\n      \n      fields ->\n        {:reply, fields, cache}\n    end\n  end\nend\n```\n\n### **3. Lazy Loading**\n\n```elixir\n# Load DSL data on demand\ndefmodule MyApp.LazyValidator do\n  def validate(module, data) do\n    # Only load fields when needed\n    fields = get_fields_lazy(module)\n    validate_fields(fields, data)\n  end\n\n  defp get_fields_lazy(module) do\n    case Process.get({:fields, module}) do\n      nil ->\n        fields = MyApp.Validator.Info.fields(module)\n        Process.put({:fields, module}, fields)\n        fields\n      \n      fields ->\n        fields\n    end\n  end\nend\n```\n\n### **4. Parallel Processing**\n\n```elixir\n# Process multiple DSLs in parallel\ndefmodule MyApp.ParallelProcessor do\n  def process_multiple(modules, data) do\n    modules\n    |> Task.async_stream(fn module ->\n      MyApp.Validator.validate(module, data)\n    end)\n    |> Enum.map(fn {:ok, result} -> result end)\n  end\nend\n```\n\n## 🔧 Performance Anti-Patterns\n\n### **1. Avoid in Transformers**\n```elixir\n# ❌ Don't do expensive I/O in transformers\ndef transform(dsl_state) do\n  # This runs at compile time!\n  external_api_call()\n  {:ok, dsl_state}\nend\n```\n\n### **2. Avoid in Verifiers**\n```elixir\n# ❌ Don't do runtime operations in verifiers\ndef verify(dsl_state) do\n  # This should be fast validation only\n  database_query()  # Too slow for compile time\n  :ok\nend\n```\n\n### **3. Avoid Complex Schema Validation**\n```elixir\n# ❌ Don't use complex validation in schemas\nschema: [\n  field: [\n    type: {:custom, __MODULE__, :expensive_validation, []}\n  ]\n]\n```\n\n## 📈 Performance Monitoring\n\n### **1. Telemetry Integration**\n\n```elixir\n# config/config.exs\nconfig :my_app, :telemetry,\n  enable_spark_metrics: true\n\n# lib/my_app/telemetry.ex\ndefmodule MyApp.Telemetry do\n  def setup do\n    :telemetry.attach_many(\n      \"spark-metrics\",\n      [\n        [:spark, :dsl, :compile],\n        [:spark, :info, :call],\n        [:spark, :transformer, :execute]\n      ],\n      &handle_event/4,\n      nil\n    )\n  end\n\n  def handle_event([:spark, :dsl, :compile], measurements, metadata, _config) do\n    Logger.info(\"DSL compilation completed\",\n      module: metadata.module,\n      duration: measurements.duration\n    )\n  end\nend\n```\n\n### **2. Performance Alerts**\n\n```elixir\n# lib/my_app/performance_monitor.ex\ndefmodule MyApp.PerformanceMonitor do\n  def check_dsl_performance(module) do\n    {compile_time, _} = :timer.tc(fn ->\n      Code.ensure_loaded?(module)\n    end)\n    \n    if compile_time > 50_000 do  # 50ms threshold\n      Logger.warning(\"Slow DSL compilation\",\n        module: module,\n        compile_time: compile_time\n      )\n    end\n  end\nend\n```\n\n## 🎯 Optimization Checklist\n\n### **Compile-Time Optimization**\n- [ ] Minimize DSL complexity\n- [ ] Optimize transformer order\n- [ ] Use conditional transformers\n- [ ] Simplify schema validation\n- [ ] Profile compilation time\n\n### **Runtime Optimization**\n- [ ] Cache expensive Info operations\n- [ ] Use lazy evaluation\n- [ ] Optimize data structures\n- [ ] Minimize memory allocations\n- [ ] Profile runtime performance\n\n### **Production Optimization**\n- [ ] Configure environment-specific settings\n- [ ] Implement caching strategies\n- [ ] Use lazy loading\n- [ ] Enable parallel processing\n- [ ] Set up performance monitoring\n\n---\n\n**Ready to optimize your DSL?** [Start with profiling →](profiling.md) "
        }
    ]
}