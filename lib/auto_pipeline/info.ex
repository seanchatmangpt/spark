defmodule AutoPipeline.Info do
  @moduledoc """
  Provides introspection functions for AutoPipeline DSL.

  REFACTOR: This module would need updates to work with Reactor:
  - Instead of tasks, it would introspect the Reactor struct
  - Use Reactor's built-in graph analysis functions
  - Leverage Reactor.Info module patterns if available
  
  Migration: Update to introspect Reactor steps instead of tasks.

  This module is automatically generated by Spark and provides functions
  to inspect the pipeline tasks defined in a module.
  """

  use Spark.InfoGenerator,
    extension: AutoPipeline.Dsl,
    sections: [:pipeline_tasks]

  @doc """
  Returns all tasks defined in the pipeline.
  """
  def tasks(module) do
    pipeline_tasks(module)
  end

  @doc """
  Returns a specific task by name.
  """
  def task(module, name) do
    tasks(module)
    |> Enum.find(&(&1.name == name))
  end

  @doc """
  Returns tasks that have no dependencies (can run first).
  
  REFACTOR: Reactor can provide this via graph analysis of steps.
  """
  def root_tasks(module) do
    tasks(module)
    |> Enum.filter(&(Enum.empty?(&1.depends_on)))
  end

  @doc """
  Returns tasks that depend on the given task.
  """
  def dependent_tasks(module, task_name) do
    tasks(module)
    |> Enum.filter(&(task_name in &1.depends_on))
  end

  @doc """
  Returns tasks that can run in parallel.
  
  REFACTOR: Use Reactor step's async? field instead.
  """
  def parallel_tasks(module) do
    tasks(module)
    |> Enum.filter(& &1.parallel)
  end

  @doc """
  Validates the pipeline configuration and returns any errors.
  
  REFACTOR: Reactor validates dependencies automatically during
  graph construction. This function becomes unnecessary.
  """
  def validate_pipeline(module) do
    tasks = tasks(module)
    
    with :ok <- validate_no_circular_dependencies(tasks),
         :ok <- validate_all_dependencies_exist(tasks) do
      :ok
    end
  end

  defp validate_no_circular_dependencies(tasks) do
    task_map = Map.new(tasks, &{&1.name, &1.depends_on})
    
    case find_circular_dependency(task_map) do
      nil -> :ok
      cycle -> {:error, "Circular dependency detected: #{inspect(cycle)}"}
    end
  end

  defp validate_all_dependencies_exist(tasks) do
    task_names = MapSet.new(tasks, & &1.name)
    
    invalid_deps =
      tasks
      |> Enum.flat_map(fn task ->
        Enum.reject(task.depends_on, &MapSet.member?(task_names, &1))
        |> Enum.map(&{task.name, &1})
      end)
    
    case invalid_deps do
      [] -> :ok
      deps -> {:error, "Invalid dependencies found: #{inspect(deps)}"}
    end
  end

  # REFACTOR: Reactor handles circular dependency detection internally
  defp find_circular_dependency(task_map) do
    task_map
    |> Map.keys()
    |> Enum.find_value(fn task ->
      case detect_cycle(task, task_map, MapSet.new(), []) do
        {:cycle, path} -> path
        :no_cycle -> nil
      end
    end)
  end

  defp detect_cycle(task, task_map, visited, path) do
    cond do
      task in visited ->
        {:cycle, Enum.reverse([task | path])}
      
      Map.has_key?(task_map, task) ->
        new_visited = MapSet.put(visited, task)
        new_path = [task | path]
        
        task_map[task]
        |> Enum.find_value(:no_cycle, fn dep ->
          case detect_cycle(dep, task_map, new_visited, new_path) do
            {:cycle, cycle_path} -> {:cycle, cycle_path}
            :no_cycle -> nil
          end
        end) || :no_cycle
      
      true ->
        :no_cycle
    end
  end
end